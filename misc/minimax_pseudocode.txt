Evaluation Parameter:
    - Chebyshev distance
    - Hop possibilities










PSEUDOCODE
-----------------------------
class HalmaState:
    attributes: 
        depth
        state: all pieces location
        parent state, current state, EVAL value

main(self,model) -> final,initial,action
    get initial time
    copy board state to local variable
    empty list to store all moves

    iteration ply

        if max layer
            # get all moves evaluation function
            for piece in all_pieces
                moves = get all possible moves (geser + loncat multiple)
                
                traversal all moves:
                    calculate evaluation function
                    append (initial,final,val) to all moves list
                
            sort all moves EVAL
            get candidate moves (EVAL > 0 or get n largest EVAL)

            run moves and save to board state tree
            HalmaState.EVAL += local EVAL
        
        if min layer
            same as max but get n smallest eval

    get max EVAL value
    get parent pos until depth 2 (our move)
    return move


-----------------------

main(self,model) -> final,initial,action
    get initial time
    copy board state to local variable
    empty list to store all moves

    iteration ply

        if max layer
            # get all moves evaluation function
            for piece in all_pieces
                moves = get all possible moves (geser + loncat multiple)
                
                traversal all moves:
                    calculate evaluation function
                    append (initial,final,val) to all moves list
                
            sort all moves EVAL
            get candidate moves (EVAL > 0 or get n largest EVAL)

            run moves and save to board state tree
            HalmaState.EVAL += local EVAL
        
        if min layer
            same as max but get n smallest eval

    get max EVAL value
    get parent pos until depth 2 (our move)
    return move



### loncat multi ###

hopping = initial pos
path_queue = initial pos

while len hopping > 0:
	pop path_queue
	get last node from path_queue
	add last node to hopped
	get hop list from last node
	
	if get-ed hop new pos not in hopped:
		add to hopping
		append to path_queue: path + new hop pos

return path_queue


moves = [
[(x0,y0),(x1,y1),(x2,y2),..,(xn,yn)],
[(x0,y0),(x1,y1),(x2,y2),..,(xn,yn)]
]

################################################################
######################## NEW GENERATION ########################
################################################################

function minimax(position, depth, alpha, beta, maximizingPlayer)
	if depth == ply or game over in position
		return static evaluation of position

	if maximizingPlayer:
		maxEval = -inf
		for each child in position:
			eval = minimax(child, depth + 1, alpha, beta, false)
			maxEval = max(maxEval, eval)
			alpha = max(alpha, eval)
			if beta <= alpha:
				break
		return maxEval

	else
		minEval = +inf
		for each child in position:
			eval = minimax(child, depth + 1, alpha, beta, true)
			minEval = min(minEval, eval)
			beta = min(beta, eval)
			if beta <= alpha:
				break
		return minEval


################################################################
function game_finish(): check if all pieces in target zone

function minimax(node, depth, alpha, beta, maximizingPlayer):
    if depth == ply or game_finish()
        node.calc_evaluation()
        return node

    if maximizingPlayer:
        max_eval = -inf     # absolute minimum value
        for move in self.moves:
            h = HalmaStateNode(node,node.get_current(),move)
            node_eval = minimax(h, depth + 1, alpha, beta, false)
            max_eval = compare max (node_eval.get_val() and max_eval) and store node in max_node
            alpha = compare max (node_eval.get_val() and alpha)
            if beta <= alpha:
                break
        return max_node

    else:
        min_eval = -inf     # absolute minimum value
        for move in self.moves:
            h = HalmaStateNode(node,node.get_current(),move)
            node_eval = minimax(h, depth + 1, alpha, beta, true)
            min_eval = compare min (node_eval.get_val() and min_eval) and store node in min_node
            beta = compare min (node_eval.get_val() and beta)
            if beta <= alpha:
                break
        return min_node

function main(model):
    alpha = -999
    beta = 999
    self.ply = ..

    # get hop moves
    # get geser moves
    self.moves append hop > geser

    model.getpapan and store to board
    h = HalmaStateNode(None,board,None)
    node_choice = minimax(h, 0, alpha, beta, True)

    backtrace node_choice until node_choice.parent is None
    move_choice = node_choice.get_move()
    initial = move_choice[0]
    final = move_choice[1]
    action = move_choice[2]

    return final, initial, action

